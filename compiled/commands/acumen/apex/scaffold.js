"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@salesforce/command");
const command_base_1 = require("../../../lib/command-base");
const options_factory_1 = require("../../../lib/options-factory");
const utils_1 = require("../../../lib/utils");
const scaffold_options_1 = require("../../../lib/scaffold-options");
const sfdx_project_1 = require("../../../lib/sfdx-project");
const sfdx_tasks_1 = require("../../../lib/sfdx-tasks");
class Scaffold extends command_base_1.CommandBase {
    constructor() {
        super(...arguments);
        this.Schemas = new Map();
    }
    async run() {
        let options;
        // Read/Write the options file if it does not exist already
        if (this.flags.options) {
            options = await options_factory_1.OptionsFactory.get(scaffold_options_1.ScaffoldOptions, this.flags.options);
            if (!options) {
                this.ux.log(`Unable to read options file: ${this.flags.options}.`);
                // Set the proper exit code to indicate violation/failure
                process.exitCode = 1;
                return;
            }
        }
        else {
            options = new scaffold_options_1.ScaffoldOptions();
            await options.loadDefaults();
        }
        if (this.flags.sobjects) {
            options.sObjectTypes.push(...this.flags.sobjects.split('.'));
        }
        this.OrgAlias = this.flags.targetusername;
        const orgId = this.org.getOrgId();
        let hasErrors = false;
        try {
            this.ux.log(`Connecting to Org: ${this.OrgAlias}(${orgId})`);
            this.ux.log('Retrieving Schemas...');
            for (const sObjectType of options.sObjectTypes) {
                this.getSchema(sObjectType);
            }
            this.ux.log('Reading ./sfdx-project.json file...');
            const project = await sfdx_project_1.default.default();
            const defaultFolder = project.getDefaultDirectory();
            this.ux.log('Generating Apex cls & cls-meta files...');
            for (const [schemaName, schema] of this.Schemas) {
                const className = `${schemaName.split('__')[0]}Test`;
                const codeFileName = className + '.cls';
                await utils_1.default.writeFile(`./${defaultFolder}/main/default/classes/${codeFileName}`, this.generateTestSetupCode(schema));
                const metaFileName = className + 'cls-meta.xml';
                await utils_1.default.writeFile(`./${defaultFolder}/main/default/classes/${metaFileName}`, Scaffold.META_XML.replace(/API_VERSION_TOKEN/, project.sourceApiVersion));
            }
        }
        catch (err) {
            process.exitCode = 1;
            throw err;
        }
        finally {
            if (hasErrors) {
                process.exitCode = 1;
            }
            this.ux.log('Done.');
        }
    }
    async getSchema(sObjectType) {
        let schema = this.Schemas.get(sObjectType);
        if (!schema) {
            schema = await sfdx_tasks_1.SfdxTasks.describeObject(this.OrgAlias, sObjectType);
            if (!schema) {
                throw new Error('The returned schema is null.');
            }
            if (!schema.fields) {
                throw new Error('The returned schema does not contain a fields member.');
            }
            this.Schemas.set(schema.name, schema);
        }
        return schema;
    }
    generateTestSetupCode(schema) {
        const name = schema.name;
        const varName = name.split('__')[0];
        const pre = '\t\t';
        //const post = ';';
        const codeLines = [
            '// This class was generated by the acumen:apex:scaffold command.',
            '@IsTest',
            'public class ${className} {',
            '',
            '\t@TestSetup',
            '\tstatic void setupTestData() {',
            `${pre}// Create instance`,
            `${pre}${name} ${varName} = new ${name}( `
        ];
        for (const field of schema.fields) {
            codeLines.push(`${pre}${field.name} = ${this.generateFieldValue(field, schema)},`);
        }
        codeLines.push(...[
            '\t\t);',
            '\t}',
            '}'
        ]);
        return codeLines.join('\n');
    }
    generateFieldValue(field, schema) {
        // https://developer.salesforce.com/docs/atlas.en-us.pages.meta/pages/pages_variables_global_objecttype_schema_fields_reference.htm
        const now = new Date();
        const simpleName = field.name.split('__')[0];
        let len = 0;
        if (field.length > 0) {
            len = field.length;
        }
        else if (field.precision > 0) {
            len = field.precision;
        }
        const getStr = (field, length) => {
            let value = field.name;
            const strLen = (length !== null && length !== void 0 ? length : len);
            // trim if we are too long
            if (strLen && value.length > strLen) {
                return value.substr(0, len);
            }
            // if we specified a length - make sure we are that long
            if (length) {
                while (value.length < length) {
                    value += get1Rand();
                }
            }
            return `'${value}'`;
        };
        const getDec = (schema) => {
            var _a;
            let num = '';
            const scale = (_a = schema.scale, (_a !== null && _a !== void 0 ? _a : 0));
            for (let index = 1; index <= (len - scale); index++) {
                num += get1Rand();
            }
            if (schema.scale > 0) {
                num += '.';
                for (let index = 1; index <= scale; index++) {
                    num += get1Rand();
                }
                return Number.parseFloat(num);
            }
            return Number.parseInt(num);
        };
        const getRand = (min, max) => {
            return Math.random() * (max - min) + min;
        };
        const get1Rand = () => {
            return getRand(0, 9);
        };
        const getValue = (field) => {
            switch (field.type) {
                case 'anytype':
                case 'String':
                case 'EncryptedString':
                    return getStr(field);
                case 'base64':
                    return Buffer.from(getStr(field)).toString('base64');
                case 'TextArea':
                    const lineCount = 3;
                    // Calculate length of each line (subract for \n) then divide 
                    const lineLength = Math.floor((len - lineCount) / 3);
                    let value = '';
                    for (let lineIndex = 0; lineIndex < lineCount; lineIndex++) {
                        value += getStr(field, lineLength);
                        value += '\n';
                    }
                    return `'${value.trimEnd()}'`;
                case 'Integer':
                case 'Long':
                case 'Double':
                case 'Percent':
                    return `${getDec(field)}`;
                case 'Currency':
                    return `$${getDec(field)}`;
                case 'address':
                    return `'123 ${field.name} St.'`;
                case 'Boolean':
                    return `${(now.getTime() % 2) > 0 ? 'true' : 'false'}`;
                case 'Date':
                    return 'Date.today()';
                case 'DateTime':
                    return 'Datetime.now()';
                case 'Time':
                    return 'Datetime.getTime()';
                case 'Email':
                    return `'user@${simpleName}.com.${this.OrgAlias}'`;
                case 'Phone':
                    return `555-${getRand(100, 999)}-${getRand(1000, 9999)} ext ${field.name}`;
                case 'Picklist':
                    const index = getRand(0, field.picklistValues.length);
                    return `'${field.picklistValues[index].value}'`;
                case 'URL':
                    return `'https://www.${simpleName}.salesforce.com.${this.OrgAlias}/index'`;
                case 'ID':
                case 'Reference':
                case 'Combobox':
                case 'DataCategoryGroupReference':
                case 'MultiPicklist':
                default:
                    return null;
            }
        };
        return getValue(field);
    }
}
exports.default = Scaffold;
Scaffold.description = command_base_1.CommandBase.messages.getMessage('apex.scaffold.commandDescription');
Scaffold.examples = [
    `$ sfdx apex.scaffold -u myOrgAlias -s Account,MyObject__c'
    Generates AccountTest.cls & MyObjectTest.cls Apex test classes (and cls-meta files) for the Account & MyObject__c SObject types. Random values assigned to required fields by default`,
    `$ sfdx apex.scaffold -u myOrgAlias -o scaffold-options.json
    Generates Apex test classes (and cls-meta files) for specified CustomObjects. The specified options file is used.`
];
Scaffold.flagsConfig = {
    sobjects: command_1.flags.string({
        char: 's',
        description: command_base_1.CommandBase.messages.getMessage('apex.scaffold.sObjectsFlagDescription')
    }),
    options: command_1.flags.string({
        char: 'o',
        description: command_base_1.CommandBase.messages.getMessage('apex.scaffold.optionsFlagDescription')
    })
};
// Comment this out if your command does not require an org username
Scaffold.requiresUsername = true;
// Set this to true if your command requires a project workspace; 'requiresProject' is false by default
Scaffold.requiresProject = true;
Scaffold.META_XML = '<?xml version="1.0" encoding="UTF-8"?>\n' +
    '<ApexClass xmlns="http://soap.sforce.com/2006/04/metadata">\n' +
    '<apiVersion>API_VERSION_TOKEN</apiVersion>\n' +
    '<status>Active</status>\n' +
    '</ApexClass>';
//# sourceMappingURL=scaffold.js.map